// kilocode_change - new file
import { z } from "zod"

/**
 * Vulnerability severity levels
 */
export const vulnerabilitySeveritySchema = z.enum(["critical", "high", "medium", "low", "informational"])

export type VulnerabilitySeverity = z.infer<typeof vulnerabilitySeveritySchema>

/**
 * Vulnerability categories
 */
export const vulnerabilityCategorySchema = z.enum([
	"reentrancy",
	"arithmetic",
	"access_control",
	"front_running",
	"logic_error",
	"gas_issue",
	"storage",
	"delegatecall",
	"timestamp",
	"tx_origin",
	"oracle_manipulation",
	"logic_flaw",
])

export type VulnerabilityCategory = z.infer<typeof vulnerabilityCategorySchema>

/**
 * Blockchain chain types
 */
export const chainTypeSchema = z.enum(["evm", "solana", "cosmos", "polkadot", "near", "aptos", "sui", "movr"])

export type ChainType = z.infer<typeof chainTypeSchema>

/**
 * EVM-specific chain identifiers
 */
export const evmChainSchema = z.enum([
	"ethereum",
	"bsc",
	"polygon",
	"arbitrum",
	"optimism",
	"avalanche",
	"fantom",
	"moonbeam",
	"base",
	"linea",
	"celo",
	"gnosis",
	"aurora",
	"harmony",
])

export type EVMChain = z.infer<typeof evmChainSchema>

/**
 * Vulnerability source (which tool detected it)
 */
export const vulnerabilitySourceSchema = z.enum([
	"slither",
	"mythril",
	"aderyn",
	"crytic",
	"foundry",
	"hardhat",
	"echidna",
	"manticore",
	"maian",
	"manual",
	"plugin",
])

export type VulnerabilitySource = z.infer<typeof vulnerabilitySourceSchema>

/**
 * Code location in contract
 */
export const codeLocationSchema = z.object({
	file: z.string(),
	line: z.number().int().positive(),
	column: z.number().int().nonnegative(),
	function: z.string().optional(),
	contract: z.string().optional(),
})

export type CodeLocation = z.infer<typeof codeLocationSchema>

/**
 * Vulnerability finding
 */
export const vulnerabilitySchema = z.object({
	id: z.string(),
	title: z.string(),
	description: z.string(),
	category: vulnerabilityCategorySchema,
	severity: vulnerabilitySeveritySchema,
	source: vulnerabilitySourceSchema,
	locations: z.array(codeLocationSchema),
	confidence: z.number().min(0).max(100),
	impact: z.string().optional(),
	exploitScenario: z.string().optional(),
	remediation: z.string().optional(),
	references: z.array(z.string()).optional(),
})

export type Vulnerability = z.infer<typeof vulnerabilitySchema>

/**
 * Vulnerability report
 */
export const vulnerabilityReportSchema = z.object({
	contractPath: z.string(),
	contractName: z.string().optional(),
	chainType: chainTypeSchema,
	evmChain: evmChainSchema.optional(),
	timestamp: z.string(),
	analysisDuration: z.number(),
	vulnerabilities: z.array(vulnerabilitySchema),
	summary: z.object({
		total: z.number(),
		critical: z.number(),
		high: z.number(),
		medium: z.number(),
		low: z.number(),
		informational: z.number(),
	}),
	toolsUsed: z.array(vulnerabilitySourceSchema),
	analysisConfig: z.record(z.string(), z.unknown()).optional(),
})

export type VulnerabilityReport = z.infer<typeof vulnerabilityReportSchema>

/**
 * Vulnerability detection result from a single tool
 */
export const detectionResultSchema = z.object({
	tool: vulnerabilitySourceSchema,
	vulnerabilities: z.array(vulnerabilitySchema),
	executionTime: z.number(),
	success: z.boolean(),
	error: z.string().optional(),
})

export type DetectionResult = z.infer<typeof detectionResultSchema>

// kilocode_change - new file

/**
 * Generate Vulnerability Report Tool
 *
 * This module provides a VS Code tool for generating vulnerability reports
 * in various formats (JSON, Markdown, HTML, SARIF).
 *
 * @see WEB3-SECURITY-PLATFORM-ARCHITECTURE.md
 */

import * as vscode from "vscode"
import * as fs from "fs"
import * as path from "path"
import type { VulnerabilityReport } from "../../../packages/core-schemas/src/web3-security/vulnerability.js"

/**
 * Generate Vulnerability Report Tool Parameters
 */
export interface GenerateVulnerabilityReportParams {
	/** Analysis results to report */
	analysisResults: VulnerabilityReport[]
	/** Output format */
	outputFormat: "json" | "markdown" | "html" | "sarif"
	/** Output file path */
	outputPath?: string
	/** Include severity classification */
	includeSeverity?: boolean
	/** Include code snippets */
	includeCodeSnippets?: boolean
	/** Include remediation suggestions */
	includeRemediation?: boolean
	/** Include executive summary */
	includeExecutiveSummary?: boolean
}

/**
 * Generate Vulnerability Report Tool
 */
export class GenerateVulnerabilityReportTool {
	readonly toolId = "generateVulnerabilityReport"
	readonly toolName = "Generate Vulnerability Report"
	readonly description = "Generate vulnerability reports in JSON, Markdown, HTML, or SARIF format"

	/**
	 * Generate vulnerability report
	 */
	async execute(params: GenerateVulnerabilityReportParams): Promise<string> {
		// Validate parameters
		this.validateParams(params)

		// Aggregate analysis results
		const aggregated = this.aggregateResults(params.analysisResults)

		// Generate report in specified format
		let report: string

		switch (params.outputFormat) {
			case "json":
				report = this.generateJSONReport(aggregated, params)
				break
			case "markdown":
				report = this.generateMarkdownReport(aggregated, params)
				break
			case "html":
				report = this.generateHTMLReport(aggregated, params)
				break
			case "sarif":
				report = this.generateSARIFReport(aggregated, params)
				break
			default:
				throw new Error(`Unsupported output format: ${params.outputFormat}`)
		}

		// Write report to file if output path is specified
		if (params.outputPath) {
			await this.writeReport(report, params.outputPath)
		}

		// Show report to user
		this.showReport(report, params.outputFormat)

		return report
	}

	/**
	 * Validate parameters
	 */
	private validateParams(params: GenerateVulnerabilityReportParams): void {
		if (!params.analysisResults || params.analysisResults.length === 0) {
			throw new Error("Analysis results are required")
		}

		const validFormats = ["json", "markdown", "html", "sarif"]
		if (!validFormats.includes(params.outputFormat)) {
			throw new Error(`Invalid output format: ${params.outputFormat}. Valid formats: ${validFormats.join(", ")}`)
		}
	}

	/**
	 * Aggregate analysis results
	 */
	private aggregateResults(results: VulnerabilityReport[]): any {
		const allVulnerabilities = results.flatMap((r) => r.vulnerabilities)

		const summary = {
			total: allVulnerabilities.length,
			critical: allVulnerabilities.filter((v) => v.severity === "critical").length,
			high: allVulnerabilities.filter((v) => v.severity === "high").length,
			medium: allVulnerabilities.filter((v) => v.severity === "medium").length,
			low: allVulnerabilities.filter((v) => v.severity === "low").length,
			informational: allVulnerabilities.filter((v) => v.severity === "informational").length,
		}

		const contracts = [...new Set(results.map((r) => r.contractPath))]

		return {
			timestamp: new Date().toISOString(),
			analysisCount: results.length,
			contracts,
			vulnerabilities: allVulnerabilities,
			summary,
		}
	}

	/**
	 * Generate JSON report
	 */
	private generateJSONReport(aggregated: any, params: GenerateVulnerabilityReportParams): string {
		const report: any = {
			metadata: {
				generatedAt: new Date().toISOString(),
				generator: "Kilo Code Web3 Security Platform",
				version: "1.0.0",
			},
			summary: aggregated.summary,
			contracts: aggregated.contracts,
			vulnerabilities: aggregated.vulnerabilities,
		}

		return JSON.stringify(report, null, 2)
	}

	/**
	 * Generate Markdown report
	 */
	private generateMarkdownReport(aggregated: any, params: GenerateVulnerabilityReportParams): string {
		const lines: string[] = []

		// Title
		lines.push("# Web3 Security Vulnerability Report")
		lines.push("")

		// Metadata
		lines.push("## Metadata")
		lines.push("")
		lines.push(`- **Generated At:** ${new Date().toISOString()}`)
		lines.push(`- **Generator:** Kilo Code Web3 Security Platform`)
		lines.push(`- **Version:** 1.0.0`)
		lines.push("")

		// Executive summary
		if (params.includeExecutiveSummary !== false) {
			lines.push("## Executive Summary")
			lines.push("")
			lines.push(`- **Total Vulnerabilities:** ${aggregated.summary.total}`)
			lines.push(`- **Critical:** ${aggregated.summary.critical}`)
			lines.push(`- **High:** ${aggregated.summary.high}`)
			lines.push(`- **Medium:** ${aggregated.summary.medium}`)
			lines.push(`- **Low:** ${aggregated.summary.low}`)
			lines.push(`- **Informational:** ${aggregated.summary.informational}`)
			lines.push("")
		}

		// Contracts analyzed
		lines.push("## Contracts Analyzed")
		lines.push("")
		aggregated.contracts.forEach((contract) => {
			lines.push(`- ${contract}`)
		})
		lines.push("")

		// Vulnerabilities
		if (params.includeSeverity !== false) {
			const severityOrder = ["critical", "high", "medium", "low", "informational"]
			severityOrder.forEach((severity) => {
				const vulnerabilities = aggregated.vulnerabilities.filter((v) => v.severity === severity)
				if (vulnerabilities.length > 0) {
					lines.push(`## ${severity.charAt(0).toUpperCase() + severity.slice(1)} Severity`)
					lines.push("")
					vulnerabilities.forEach((vuln) => {
						lines.push(`### ${vuln.title}`)
						lines.push("")
						lines.push(`**Category:** ${vuln.category}`)
						lines.push("")
						lines.push(`**Description:** ${vuln.description}`)
						lines.push("")

						if (params.includeCodeSnippets !== false && vuln.codeLocation) {
							lines.push("**Code Location:**")
							lines.push("```solidity")
							lines.push(vuln.codeLocation.snippet || "// No snippet available")
							lines.push("```")
							lines.push("")
						}

						if (params.includeRemediation !== false && vuln.remediation) {
							lines.push("**Remediation:**")
							lines.push(vuln.remediation)
							lines.push("")
						}

						lines.push("---")
						lines.push("")
					})
				}
			})
		} else {
			lines.push("## Vulnerabilities")
			lines.push("")
			aggregated.vulnerabilities.forEach((vuln) => {
				lines.push(`### ${vuln.title}`)
				lines.push("")
				lines.push(`**Category:** ${vuln.category}`)
				lines.push("")
				lines.push(`**Description:** ${vuln.description}`)
				lines.push("")

				if (params.includeCodeSnippets !== false && vuln.codeLocation) {
					lines.push("**Code Location:**")
					lines.push("```solidity")
					lines.push(vuln.codeLocation.snippet || "// No snippet available")
					lines.push("```")
					lines.push("")
				}

				if (params.includeRemediation !== false && vuln.remediation) {
					lines.push("**Remediation:**")
					lines.push(vuln.remediation)
					lines.push("")
				}

				lines.push("---")
				lines.push("")
			})
		}

		return lines.join("\n")
	}

	/**
	 * Generate HTML report
	 */
	private generateHTMLReport(aggregated: any, params: GenerateVulnerabilityReportParams): string {
		const lines: string[] = []

		lines.push("<!DOCTYPE html>")
		lines.push("<html>")
		lines.push("<head>")
		lines.push("<title>Web3 Security Vulnerability Report</title>")
		lines.push("<style>")
		lines.push("body { font-family: Arial, sans-serif; margin: 20px; }")
		lines.push("h1 { color: #333; }")
		lines.push("h2 { color: #555; }")
		lines.push("h3 { color: #666; }")
		lines.push(".critical { color: #d32f2f; }")
		lines.push(".high { color: #f57c00; }")
		lines.push(".medium { color: #fbc02d; }")
		lines.push(".low { color: #388e3c; }")
		lines.push(".informational { color: #1976d2; }")
		lines.push("</style>")
		lines.push("</head>")
		lines.push("<body>")

		// Title
		lines.push("<h1>Web3 Security Vulnerability Report</h1>")

		// Metadata
		lines.push("<h2>Metadata</h2>")
		lines.push("<ul>")
		lines.push(`<li><strong>Generated At:</strong> ${new Date().toISOString()}</li>`)
		lines.push(`<li><strong>Generator:</strong> Kilo Code Web3 Security Platform</li>`)
		lines.push(`<li><strong>Version:</strong> 1.0.0</li>`)
		lines.push("</ul>")

		// Executive summary
		if (params.includeExecutiveSummary !== false) {
			lines.push("<h2>Executive Summary</h2>")
			lines.push("<ul>")
			lines.push(`<li><strong>Total Vulnerabilities:</strong> ${aggregated.summary.total}</li>`)
			lines.push(`<li><strong>Critical:</strong> ${aggregated.summary.critical}</li>`)
			lines.push(`<li><strong>High:</strong> ${aggregated.summary.high}</li>`)
			lines.push(`<li><strong>Medium:</strong> ${aggregated.summary.medium}</li>`)
			lines.push(`<li><strong>Low:</strong> ${aggregated.summary.low}</li>`)
			lines.push(`<li><strong>Informational:</strong> ${aggregated.summary.informational}</li>`)
			lines.push("</ul>")
		}

		// Contracts analyzed
		lines.push("<h2>Contracts Analyzed</h2>")
		lines.push("<ul>")
		aggregated.contracts.forEach((contract) => {
			lines.push(`<li>${contract}</li>`)
		})
		lines.push("</ul>")

		// Vulnerabilities
		if (params.includeSeverity !== false) {
			const severityOrder = ["critical", "high", "medium", "low", "informational"]
			severityOrder.forEach((severity) => {
				const vulnerabilities = aggregated.vulnerabilities.filter((v) => v.severity === severity)
				if (vulnerabilities.length > 0) {
					lines.push(
						`<h2 class="${severity}">${severity.charAt(0).toUpperCase() + severity.slice(1)} Severity</h2>`,
					)
					vulnerabilities.forEach((vuln) => {
						lines.push("<h3>" + vuln.title + "</h3>")
						lines.push("<p><strong>Category:</strong> " + vuln.category + "</p>")
						lines.push("<p><strong>Description:</strong> " + vuln.description + "</p>")

						if (params.includeCodeSnippets !== false && vuln.codeLocation) {
							lines.push("<p><strong>Code Location:</strong></p>")
							lines.push(
								"<pre><code>" +
									(vuln.codeLocation.snippet || "// No snippet available") +
									"</code></pre>",
							)
						}

						if (params.includeRemediation !== false && vuln.remediation) {
							lines.push("<p><strong>Remediation:</strong></p>")
							lines.push("<p>" + vuln.remediation + "</p>")
						}

						lines.push("<hr>")
					})
				}
			})
		} else {
			lines.push("<h2>Vulnerabilities</h2>")
			aggregated.vulnerabilities.forEach((vuln) => {
				lines.push("<h3>" + vuln.title + "</h3>")
				lines.push("<p><strong>Category:</strong> " + vuln.category + "</p>")
				lines.push("<p><strong>Description:</strong> " + vuln.description + "</p>")

				if (params.includeCodeSnippets !== false && vuln.codeLocation) {
					lines.push("<p><strong>Code Location:</strong></p>")
					lines.push(
						"<pre><code>" + (vuln.codeLocation.snippet || "// No snippet available") + "</code></pre>",
					)
				}

				if (params.includeRemediation !== false && vuln.remediation) {
					lines.push("<p><strong>Remediation:</strong></p>")
					lines.push("<p>" + vuln.remediation + "</p>")
				}

				lines.push("<hr>")
			})
		}

		lines.push("</body>")
		lines.push("</html>")

		return lines.join("\n")
	}

	/**
	 * Generate SARIF report
	 */
	private generateSARIFReport(aggregated: any, params: GenerateVulnerabilityReportParams): string {
		const sarif: any = {
			version: "2.1.0",
			$schema: "https://json.schemastore.org/sarif-2.1.0.json",
			runs: [
				{
					tool: {
						driver: {
							name: "Kilo Code Web3 Security Platform",
							version: "1.0.0",
							informationUri: "https://github.com/kilocode/kilocode",
						},
					},
					results: aggregated.vulnerabilities.map((vuln) => ({
						ruleId: vuln.category,
						level: this.mapSeverityToSARIFLevel(vuln.severity),
						message: {
							text: vuln.description,
						},
						locations: vuln.codeLocation
							? [
									{
										physicalLocation: {
											artifactLocation: {
												uri: vuln.codeLocation.filePath,
											},
											region: {
												startLine: vuln.codeLocation.startLine,
												endLine: vuln.codeLocation.endLine,
												startColumn: vuln.codeLocation.startColumn,
												endColumn: vuln.codeLocation.endColumn,
											},
										},
									},
								]
							: [],
					})),
				},
			],
		}

		return JSON.stringify(sarif, null, 2)
	}

	/**
	 * Map severity to SARIF level
	 */
	private mapSeverityToSARIFLevel(severity: string): string {
		switch (severity) {
			case "critical":
				return "error"
			case "high":
				return "error"
			case "medium":
				return "warning"
			case "low":
				return "warning"
			case "informational":
				return "note"
			default:
				return "note"
		}
	}

	/**
	 * Write report to file
	 */
	private async writeReport(report: string, outputPath: string): Promise<void> {
		const dir = path.dirname(outputPath)
		if (!fs.existsSync(dir)) {
			fs.mkdirSync(dir, { recursive: true })
		}

		fs.writeFileSync(outputPath, report, "utf-8")

		vscode.window.showInformationMessage(`Report saved to: ${outputPath}`)
	}

	/**
	 * Show report to user
	 */
	private showReport(report: string, format: string): void {
		// Create output panel
		const panel = vscode.window.createWebviewPanel("web3SecurityVulnerabilityReport")

		// Set HTML content
		if (format === "html") {
			panel.webview.html = report
		} else {
			panel.webview.html = this.wrapInHTML(report, format)
		}

		// Show panel
		panel.reveal(vscode.ViewColumn.One)

		// Store context for potential follow-up actions
		panel.webview.postMessage({
			command: "setContext",
			data: report,
		})
	}

	/**
	 * Wrap content in HTML for display
	 */
	private wrapInHTML(content: string, format: string): string {
		return `
<!DOCTYPE html>
<html>
<head>
	<title>Web3 Security Vulnerability Report (${format.toUpperCase()})</title>
	<style>
		body { font-family: 'Courier New', monospace; margin: 20px; background: #1e1e1e; color: #d4d4d4d; }
		pre { background: #2d2d2d; padding: 15px; border-radius: 5px; overflow-x: auto; }
	</style>
</head>
<body>
	<h1>Web3 Security Vulnerability Report (${format.toUpperCase()})</h1>
	<pre>${content}</pre>
</body>
</html>
		`
	}
}

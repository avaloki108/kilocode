// kilocode_change - new file
import type { Vulnerability, VulnerabilityCategory, VulnerabilitySeverity, CodeLocation } from "@kilocode/core-schemas"

/**
 * VulnerabilityDetector - Base class for pattern-based vulnerability detection
 *
 * This abstract class provides the foundation for specialized vulnerability detectors
 * that identify specific vulnerability patterns in smart contracts.
 */
export abstract class VulnerabilityDetector {
	/**
	 * Detector metadata
	 */
	readonly detectorId: string
	readonly detectorName: string
	readonly detectorVersion: string
	readonly description: string
	readonly supportedCategories: VulnerabilityCategory[]
	readonly supportedChains: string[]

	/**
	 * Create a new vulnerability detector
	 */
	constructor(
		detectorId: string,
		detectorName: string,
		description: string,
		supportedCategories: VulnerabilityCategory[],
		supportedChains: string[] = ["evm"],
	) {
		this.detectorId = detectorId
		this.detectorName = detectorName
		this.description = description
		this.supportedCategories = supportedCategories
		this.supportedChains = supportedChains
		this.detectorVersion = "1.0.0"
	}

	/**
	 * Detect vulnerabilities in the given code
	 */
	abstract detect(params: DetectionParams): Promise<Vulnerability[]>

	/**
	 * Check if this detector supports a specific vulnerability category
	 */
	supportsCategory(category: VulnerabilityCategory): boolean {
		return this.supportedCategories.includes(category)
	}

	/**
	 * Check if this detector supports a specific chain
	 */
	supportsChain(chain: string): boolean {
		return this.supportedChains.includes(chain)
	}

	/**
	 * Get detector metadata
	 */
	getMetadata(): DetectorMetadata {
		return {
			id: this.detectorId,
			name: this.detectorName,
			version: this.detectorVersion,
			description: this.description,
			supportedCategories: this.supportedCategories,
			supportedChains: this.supportedChains,
		}
	}

	/**
	 * Validate detection parameters
	 */
	protected validateParams(params: DetectionParams): void {
		if (!params.contractPath) {
			throw new Error("Contract path is required")
		}
		if (!params.code) {
			throw new Error("Contract code is required")
		}
	}
}

/**
 * Parameters for vulnerability detection
 */
export interface DetectionParams {
	contractPath: string
	contractName?: string
	code: string
	chainType?: string
	analysisContext?: Record<string, unknown>
	targetCategories?: VulnerabilityCategory[]
}

/**
 * Detector metadata
 */
export interface DetectorMetadata {
	id: string
	name: string
	version: string
	description: string
	supportedCategories: VulnerabilityCategory[]
	supportedChains: string[]
}

/**
 * Detection result with confidence score
 */
export interface DetectionResult {
	vulnerabilities: Vulnerability[]
	confidence: number
	detectorId: string
	executionTime: number
}

/**
 * Create a vulnerability detector from a class definition
 */
export function createDetector(detectorClass: new () => VulnerabilityDetector): VulnerabilityDetector {
	const detector = new detectorClass()
	return detector
}

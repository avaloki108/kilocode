// kilocode_change - new file

/**
 * Vulnerability Report Generator Service
 *
 * This module provides a service for generating vulnerability reports
 * in various formats (JSON, Markdown, HTML, SARIF).
 *
 * @see WEB3-SECURITY-PLATFORM-ARCHITECTURE.md
 */

import * as fs from "fs"
import * as path from "path"
import type {
	VulnerabilityReport,
	Vulnerability,
} from "../../../packages/core-schemas/src/web3-security/vulnerability.js"

/**
 * Report Generation Options
 */
export interface ReportGenerationOptions {
	/** Include severity classification */
	includeSeverity?: boolean
	/** Include code snippets */
	includeCodeSnippets?: boolean
	/** Include remediation suggestions */
	includeRemediation?: boolean
	/** Include executive summary */
	includeExecutiveSummary?: boolean
	/** Include vulnerability details */
	includeDetails?: boolean
	/** Include recommendations */
	includeRecommendations?: boolean
	/** Custom template path */
	templatePath?: string
}

/**
 * Vulnerability Report Generator
 */
export class VulnerabilityReportGenerator {
	/**
	 * Generate vulnerability report
	 */
	async generateReport(
		reports: VulnerabilityReport[],
		format: "json" | "markdown" | "html" | "sarif",
		outputPath: string,
		options?: ReportGenerationOptions,
	): Promise<void> {
		// Validate parameters
		this.validateParameters(reports, format, outputPath)

		// Aggregate analysis results
		const aggregated = this.aggregateResults(reports)

		// Generate report in specified format
		let report: string

		switch (format) {
			case "json":
				report = this.generateJSONReport(aggregated, options)
				break
			case "markdown":
				report = this.generateMarkdownReport(aggregated, options)
				break
			case "html":
				report = this.generateHTMLReport(aggregated, options)
				break
			case "sarif":
				report = this.generateSARIFReport(aggregated, options)
				break
			default:
				throw new Error(`Unsupported format: ${format}`)
		}

		// Write report to file
		await this.writeReport(report, outputPath)
	}

	/**
	 * Validate parameters
	 */
	private validateParameters(reports: VulnerabilityReport[], format: string, outputPath: string): void {
		if (!reports || reports.length === 0) {
			throw new Error("At least one report is required")
		}

		const validFormats = ["json", "markdown", "html", "sarif"]
		if (!validFormats.includes(format)) {
			throw new Error(`Invalid format: ${format}. Valid formats: ${validFormats.join(", ")}`)
		}

		if (!outputPath) {
			throw new Error("Output path is required")
		}
	}

	/**
	 * Aggregate analysis results
	 */
	private aggregateResults(reports: VulnerabilityReport[]): any {
		const allVulnerabilities = reports.flatMap((r) => r.vulnerabilities)

		const summary = {
			total: allVulnerabilities.length,
			critical: allVulnerabilities.filter((v) => v.severity === "critical").length,
			high: allVulnerabilities.filter((v) => v.severity === "high").length,
			medium: allVulnerabilities.filter((v) => v.severity === "medium").length,
			low: allVulnerabilities.filter((v) => v.severity === "low").length,
			informational: allVulnerabilities.filter((v) => v.severity === "informational").length,
		}

		const contracts = [...new Set(reports.map((r) => r.contractPath))]

		return {
			metadata: {
				generatedAt: new Date().toISOString(),
				generator: "Kilo Code Web3 Security Platform",
				version: "1.0.0",
			},
			summary,
			contracts,
			vulnerabilities: allVulnerabilities,
		}
	}

	/**
	 * Generate JSON report
	 */
	private generateJSONReport(aggregated: any, options?: ReportGenerationOptions): string {
		const report: any = {
			...aggregated,
			options: {
				includeSeverity: options?.includeSeverity !== false,
				includeCodeSnippets: options?.includeCodeSnippets !== false,
				includeRemediation: options?.includeRemediation !== false,
				includeExecutiveSummary: options?.includeExecutiveSummary !== false,
				includeDetails: options?.includeDetails !== false,
				includeRecommendations: options?.includeRecommendations !== false,
			},
		}

		return JSON.stringify(report, null, 2)
	}

	/**
	 * Generate Markdown report
	 */
	private generateMarkdownReport(aggregated: any, options?: ReportGenerationOptions): string {
		const lines: string[] = []

		// Title
		lines.push("# Web3 Security Vulnerability Report")
		lines.push("")

		// Metadata
		lines.push("## Metadata")
		lines.push("")
		lines.push(`- **Generated At:** ${aggregated.metadata.generatedAt}`)
		lines.push(`- **Generator:** ${aggregated.metadata.generator}`)
		lines.push(`- **Version:** ${aggregated.metadata.version}`)
		lines.push("")

		// Executive summary
		if (options?.includeExecutiveSummary !== false) {
			lines.push("## Executive Summary")
			lines.push("")
			lines.push(`- **Total Vulnerabilities:** ${aggregated.summary.total}`)
			lines.push(`- **Critical:** ${aggregated.summary.critical}`)
			lines.push(`- **High:** ${aggregated.summary.high}`)
			lines.push(`- **Medium:** ${aggregated.summary.medium}`)
			lines.push(`- **Low:** ${aggregated.summary.low}`)
			lines.push(`- **Informational:** ${aggregated.summary.informational}`)
			lines.push("")
		}

		// Contracts analyzed
		lines.push("## Contracts Analyzed")
		lines.push("")
		aggregated.contracts.forEach((contract) => {
			lines.push(`- ${contract}`)
		})
		lines.push("")

		// Vulnerabilities
		if (options?.includeSeverity !== false) {
			const severityOrder = ["critical", "high", "medium", "low", "informational"]
			severityOrder.forEach((severity) => {
				const vulnerabilities = aggregated.vulnerabilities.filter((v) => v.severity === severity)
				if (vulnerabilities.length > 0) {
					lines.push(`## ${severity.charAt(0).toUpperCase() + severity.slice(1)} Severity`)
					lines.push("")
					vulnerabilities.forEach((vuln) => {
						this.addVulnerabilityToMarkdown(lines, vuln, options)
					})
				}
			})
		} else {
			lines.push("## Vulnerabilities")
			lines.push("")
			aggregated.vulnerabilities.forEach((vuln) => {
				this.addVulnerabilityToMarkdown(lines, vuln, options)
			})
		}

		// Recommendations
		if (options?.includeRecommendations !== false) {
			lines.push("## Recommendations")
			lines.push("")
			this.addRecommendationsToMarkdown(lines, aggregated.vulnerabilities)
		}

		return lines.join("\n")
	}

	/**
	 * Add vulnerability to Markdown
	 */
	private addVulnerabilityToMarkdown(lines: string[], vuln: Vulnerability, options?: ReportGenerationOptions): void {
		lines.push(`### ${vuln.title}`)
		lines.push("")
		lines.push(`**Category:** ${vuln.category}`)
		lines.push("")
		lines.push(`**Severity:** ${vuln.severity}`)
		lines.push("")
		lines.push(`**Description:** ${vuln.description}`)
		lines.push("")

		if (options?.includeCodeSnippets !== false && vuln.codeLocation) {
			lines.push("**Code Location:**")
			lines.push("```solidity")
			lines.push(vuln.codeLocation.snippet || "// No snippet available")
			lines.push("```")
			lines.push("")
		}

		if (options?.includeRemediation !== false && vuln.remediation) {
			lines.push("**Remediation:**")
			lines.push(vuln.remediation)
			lines.push("")
		}

		if (options?.includeDetails !== false && vuln.details) {
			lines.push("**Details:**")
			lines.push(vuln.details)
			lines.push("")
		}

		lines.push("---")
		lines.push("")
	}

	/**
	 * Add recommendations to Markdown
	 */
	private addRecommendationsToMarkdown(lines: string[], vulnerabilities: Vulnerability[]): void {
		const criticalCount = vulnerabilities.filter((v) => v.severity === "critical").length
		const highCount = vulnerabilities.filter((v) => v.severity === "high").length

		if (criticalCount > 0 || highCount > 0) {
			lines.push("### Priority Actions Required")
			lines.push("")
			lines.push(
				"- **Immediate action required:** Critical and high severity vulnerabilities must be addressed before deployment.",
			)
			lines.push("- **Code review:** Conduct thorough code review of affected functions.")
			lines.push("- **Testing:** Implement comprehensive testing including fuzzing and symbolic execution.")
			lines.push("- **Audit:** Consider professional security audit for critical issues.")
			lines.push("")
		}

		const categories = [...new Set(vulnerabilities.map((v) => v.category))]
		lines.push("### Common Vulnerability Patterns")
		lines.push("")
		categories.forEach((category) => {
			const count = vulnerabilities.filter((v) => v.category === category).length
			lines.push(`- **${category}:** ${count} vulnerabilities found`)
		})
		lines.push("")

		lines.push("### General Recommendations")
		lines.push("")
		lines.push("- Use access control modifiers (onlyOwner, onlyAdmin) appropriately.")
		lines.push("- Implement reentrancy guards using Checks-Effects-Interactions pattern.")
		lines.push("- Use SafeMath or Solidity 0.8+ for arithmetic operations.")
		lines.push("- Validate all external calls and handle failures gracefully.")
		lines.push("- Use events for critical state changes.")
		lines.push("- Implement proper input validation and bounds checking.")
		lines.push("- Use timelocks for sensitive operations.")
		lines.push("- Avoid using tx.origin for authorization.")
		lines.push("- Implement emergency pause mechanisms.")
		lines.push("")
	}

	/**
	 * Generate HTML report
	 */
	private generateHTMLReport(aggregated: any, options?: ReportGenerationOptions): string {
		const lines: string[] = []

		lines.push("<!DOCTYPE html>")
		lines.push("<html>")
		lines.push("<head>")
		lines.push("<title>Web3 Security Vulnerability Report</title>")
		lines.push("<style>")
		lines.push("body { font-family: Arial, sans-serif; margin: 20px; }")
		lines.push("h1 { color: #333; }")
		lines.push("h2 { color: #555; }")
		lines.push("h3 { color: #666; }")
		lines.push(".critical { color: #d32f2f; }")
		lines.push(".high { color: #f57c00; }")
		lines.push(".medium { color: #fbc02d; }")
		lines.push(".low { color: #388e3c; }")
		lines.push(".informational { color: #1976d2; }")
		lines.push(".vulnerability { border: 1px solid #ddd; padding: 15px; margin-bottom: 15px; border-radius: 5px; }")
		lines.push(
			".severity { display: inline-block; padding: 3px 8px; border-radius: 3px; font-size: 12px; font-weight: bold; }",
		)
		lines.push(".severity.critical { background: #d32f2f; color: white; }")
		lines.push(".severity.high { background: #f57c00; color: white; }")
		lines.push(".severity.medium { background: #fbc02d; color: white; }")
		lines.push(".severity.low { background: #388e3c; color: white; }")
		lines.push(".severity.informational { background: #1976d2; color: white; }")
		lines.push("</style>")
		lines.push("</head>")
		lines.push("<body>")

		// Title
		lines.push("<h1>Web3 Security Vulnerability Report</h1>")

		// Metadata
		lines.push("<h2>Metadata</h2>")
		lines.push("<ul>")
		lines.push(`<li><strong>Generated At:</strong> ${aggregated.metadata.generatedAt}</li>`)
		lines.push(`<li><strong>Generator:</strong> ${aggregated.metadata.generator}</li>`)
		lines.push(`<li><strong>Version:</strong> ${aggregated.metadata.version}</li>`)
		lines.push("</ul>")

		// Executive summary
		if (options?.includeExecutiveSummary !== false) {
			lines.push("<h2>Executive Summary</h2>")
			lines.push("<ul>")
			lines.push(`<li><strong>Total Vulnerabilities:</strong> ${aggregated.summary.total}</li>`)
			lines.push(`<li><strong>Critical:</strong> ${aggregated.summary.critical}</li>`)
			lines.push(`<li><strong>High:</strong> ${aggregated.summary.high}</li>`)
			lines.push(`<li><strong>Medium:</strong> ${aggregated.summary.medium}</li>`)
			lines.push(`<li><strong>Low:</strong> ${aggregated.summary.low}</li>`)
			lines.push(`<li><strong>Informational:</strong> ${aggregated.summary.informational}</li>`)
			lines.push("</ul>")
		}

		// Contracts analyzed
		lines.push("<h2>Contracts Analyzed</h2>")
		lines.push("<ul>")
		aggregated.contracts.forEach((contract) => {
			lines.push(`<li>${contract}</li>`)
		})
		lines.push("</ul>")

		// Vulnerabilities
		if (options?.includeSeverity !== false) {
			const severityOrder = ["critical", "high", "medium", "low", "informational"]
			severityOrder.forEach((severity) => {
				const vulnerabilities = aggregated.vulnerabilities.filter((v) => v.severity === severity)
				if (vulnerabilities.length > 0) {
					lines.push(
						`<h2 class="${severity}">${severity.charAt(0).toUpperCase() + severity.slice(1)} Severity</h2>`,
					)
					vulnerabilities.forEach((vuln) => {
						this.addVulnerabilityToHTML(lines, vuln, options)
					})
				}
			})
		} else {
			lines.push("<h2>Vulnerabilities</h2>")
			aggregated.vulnerabilities.forEach((vuln) => {
				this.addVulnerabilityToHTML(lines, vuln, options)
			})
		}

		// Recommendations
		if (options?.includeRecommendations !== false) {
			lines.push("<h2>Recommendations</h2>")
			this.addRecommendationsToHTML(lines, aggregated.vulnerabilities)
		}

		lines.push("</body>")
		lines.push("</html>")

		return lines.join("\n")
	}

	/**
	 * Add vulnerability to HTML
	 */
	private addVulnerabilityToHTML(lines: string[], vuln: Vulnerability, options?: ReportGenerationOptions): void {
		lines.push("<div class='vulnerability'>")
		lines.push("<h3>" + vuln.title + "</h3>")
		lines.push("<p><strong>Category:</strong> " + vuln.category + "</p>")
		lines.push(
			"<p><strong>Severity:</strong> <span class='severity " +
				vuln.severity +
				"'>" +
				vuln.severity.toUpperCase() +
				"</span></p>",
		)
		lines.push("<p><strong>Description:</strong> " + vuln.description + "</p>")

		if (options?.includeCodeSnippets !== false && vuln.codeLocation) {
			lines.push("<p><strong>Code Location:</strong></p>")
			lines.push("<pre><code>" + (vuln.codeLocation.snippet || "// No snippet available") + "</code></pre>")
		}

		if (options?.includeRemediation !== false && vuln.remediation) {
			lines.push("<p><strong>Remediation:</strong></p>")
			lines.push("<p>" + vuln.remediation + "</p>")
		}

		if (options?.includeDetails !== false && vuln.details) {
			lines.push("<p><strong>Details:</strong></p>")
			lines.push("<p>" + vuln.details + "</p>")
		}

		lines.push("</div>")
	}

	/**
	 * Add recommendations to HTML
	 */
	private addRecommendationsToHTML(lines: string[], vulnerabilities: Vulnerability[]): void {
		const criticalCount = vulnerabilities.filter((v) => v.severity === "critical").length
		const highCount = vulnerabilities.filter((v) => v.severity === "high").length

		if (criticalCount > 0 || highCount > 0) {
			lines.push("<h3>Priority Actions Required</h3>")
			lines.push("<ul>")
			lines.push(
				"<li><strong>Immediate action required:</strong> Critical and high severity vulnerabilities must be addressed before deployment.</li>",
			)
			lines.push("<li><strong>Code review:</strong> Conduct thorough code review of affected functions.</li>")
			lines.push(
				"<li><strong>Testing:</strong> Implement comprehensive testing including fuzzing and symbolic execution.</li>",
			)
			lines.push("<li><strong>Audit:</strong> Consider professional security audit for critical issues.</li>")
			lines.push("</ul>")
		}

		const categories = [...new Set(vulnerabilities.map((v) => v.category))]
		lines.push("<h3>Common Vulnerability Patterns</h3>")
		lines.push("<ul>")
		categories.forEach((category) => {
			const count = vulnerabilities.filter((v) => v.category === category).length
			lines.push(`<li><strong>${category}:</strong> ${count} vulnerabilities found</li>`)
		})
		lines.push("</ul>")

		lines.push("<h3>General Recommendations</h3>")
		lines.push("<ul>")
		lines.push("<li>Use access control modifiers (onlyOwner, onlyAdmin) appropriately.</li>")
		lines.push("<li>Implement reentrancy guards using Checks-Effects-Interactions pattern.</li>")
		lines.push("<li>Use SafeMath or Solidity 0.8+ for arithmetic operations.</li>")
		lines.push("<li>Validate all external calls and handle failures gracefully.</li>")
		lines.push("<li>Use events for critical state changes.</li>")
		lines.push("<li>Implement proper input validation and bounds checking.</li>")
		lines.push("<li>Use timelocks for sensitive operations.</li>")
		lines.push("<li>Avoid using tx.origin for authorization.</li>")
		lines.push("<li>Implement emergency pause mechanisms.</li>")
		lines.push("</ul>")
	}

	/**
	 * Generate SARIF report
	 */
	private generateSARIFReport(aggregated: any, options?: ReportGenerationOptions): string {
		const sarif: any = {
			version: "2.1.0",
			$schema: "https://json.schemastore.org/sarif-2.1.0.json",
			runs: [
				{
					tool: {
						driver: {
							name: "Kilo Code Web3 Security Platform",
							version: "1.0.0",
							informationUri: "https://github.com/kilocode/kilocode",
						},
					},
					results: aggregated.vulnerabilities.map((vuln) => ({
						ruleId: vuln.category,
						level: this.mapSeverityToSARIFLevel(vuln.severity),
						message: {
							text: vuln.description,
						},
						locations: vuln.codeLocation
							? [
									{
										physicalLocation: {
											artifactLocation: {
												uri: vuln.codeLocation.filePath,
											},
											region: {
												startLine: vuln.codeLocation.startLine,
												endLine: vuln.codeLocation.endLine,
												startColumn: vuln.codeLocation.startColumn,
												endColumn: vuln.codeLocation.endColumn,
											},
										},
									},
								]
							: [],
					})),
				},
			],
		}

		return JSON.stringify(sarif, null, 2)
	}

	/**
	 * Map severity to SARIF level
	 */
	private mapSeverityToSARIFLevel(severity: string): string {
		switch (severity) {
			case "critical":
				return "error"
			case "high":
				return "error"
			case "medium":
				return "warning"
			case "low":
				return "warning"
			case "informational":
				return "note"
			default:
				return "note"
		}
	}

	/**
	 * Write report to file
	 */
	private async writeReport(report: string, outputPath: string): Promise<void> {
		const dir = path.dirname(outputPath)
		if (!fs.existsSync(dir)) {
			fs.mkdirSync(dir, { recursive: true })
		}

		fs.writeFileSync(outputPath, report, "utf-8")
	}

	/**
	 * Load custom template
	 */
	private loadCustomTemplate(templatePath: string): string {
		if (!fs.existsSync(templatePath)) {
			throw new Error(`Template file not found: ${templatePath}`)
		}

		return fs.readFileSync(templatePath, "utf-8")
	}

	/**
	 * Apply custom template
	 */
	private applyCustomTemplate(template: string, data: any): string {
		return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
			return data[key] || match
		})
	}
}
